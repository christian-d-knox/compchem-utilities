+=================================================================================+
|                                                                                 |
|    ____                      _   _ _   _ _                        ____    ___   |
|   / ___|___  _ __ ___  _ __ | | | | |_(_| |___  __   _____ _ __  |___ \  / _ \  |
|  | |   / _ \| '_ ` _ \| '_ \| | | | __| | / __| \ \ / / _ | '__|   __) || | | | |
|  | |__| (_) | | | | | | |_) | |_| | |_| | \__ \  \ V |  __| |     / __/ | |_| | |
|   \____\___/|_| |_| |_| .__/ \___/ \__|_|_|___/   \_/ \___|_|    |_____(_\___/  |
|                       |_|                                                       |
|                                                                                 |
+=================================================================================+

Welcome to Computational Chemistry Utilities (CompUtils)!
This utility is brought to you by Christian Drew Knox, for the Peng Liu Group at The
University of Pittsburgh.

This program exists to combine many in-house scripts we have developed over the years
into one comprehensive package for anyone's use.

Current Implementations:
- Every function is pre-packaged with runall functionality
- Both qg16, qorca, and qchem submission
- genosp and genCC (mixed basis not implemented)
- pg2xyz
- genbench
- Installer file for critical dependencies
- Colored terminal text (wow!)

This utility comes pre-packaged with terminal flags that trigger its corresponding
features. This manual is sorted by these flags, in order of what I anticipate to be
most commonly used.

*************************************************************************************

+===================================================================================+
|                                                                                   |
|           ____   _                                      _                         |
|          / ___| | |__     __ _   _ __     __ _    ___  | |   ___     __ _         |
|         | |     | '_ \   / _` | | '_ \   / _` |  / _ \ | |  / _ \   / _` |        |
|         | |___  | | | | | (_| | | | | | | (_| | |  __/ | | | (_) | | (_| |        |
|          \____| |_| |_|  \__,_| |_| |_|  \__, |  \___| |_|  \___/   \__, |        |
|                                          |___/                      |___/         |
|                                                                                   |
+===================================================================================+

--------------------------------CompUtils 2.0 Release--------------------------------
- Completely refactored code into Python 3.10 to allow for match / case statements
instead of if / elif / else chains (speed improvement)
 - Refactored job submission to match Program with File Extension by match / case
  - Added Q-Chem job submission
 - Refactored file creation to match / case for File Extension
  - Default extensions are hardcoded but user changeable, similar to other defaults
 - Refactored both of the above to work with new Method determination
- Refactored default programs to user defined pairings of Method and Program
 - Provided a hardcoded default as fallback
 - Also provided hardcoded default single point method to avoid potential errors
- Re-wrote coordinate scraper to rely on external pg2xyz (speed improvement of ~10x)
- Reduced internal copypasta with more globally defined functions
- Added check for benchmarking file to block access to benchmarking flag
- Added preliminary section for QChem single point building
- Refactored default CPU and RAM assignments to use core:mem ratio
 - Provided a normal and high mem ratio for user tweaking (currently DLPNO-CCSD(T))
- Added colored text functionality to make terminal print easier to read / interpret
- Created installer file to automatically install package dependencies
 - Also creates aliases for proper python module and for CompUtils itself,
 immediately sources alias file for user convenience
- Re-wrote job CPU and RAM finder to be order-independent in the first 5 lines
- Implemented a working version of Job Stalking

*************************************************************************************

+===================================================================================+
|                                                                                   |
|                           _____   _                                               |
|                          |  ___| | |   __ _    __ _   ___                         |
|                          | |_    | |  / _` |  / _` | / __|                        |
|                          |  _|   | | | (_| | | (_| | \__ \                        |
|                          |_|     |_|  \__,_|  \__, | |___/                        |
|                                               |___/                               |
|                                                                                   |
+===================================================================================+

---------------------------------------run flag--------------------------------------

The runJob function is accessed through the -r or --run flag, and must receive an
escaped file name or list of names as an argument. Multiple filenames can be
accepted by escaping the wildcard in the terminal, as shown in the example below:

    cu -r \*.gjf

The run function distinguishes between Gaussian16, ORCA, and QChem jobs based on
their respective file extensions. These defaults can be changed within CompUtils.
CPU and RAM determinations, however are based off of the first few lines, and as such
they must be formatted in a specific way. The first five lines of the input file must
contain the CPU and RAM information. 

For Gaussian16 jobs, two different CPU structures are accepted:
%nprocshared=12           OR          %nproc=12
%mem=24GB                 OR          %mem=24GB

For ORCA submissions, one CPU and RAM input configuration is accepted:
%pal=12
end
%maxcore=6000

For QChem submissions, two configurations are accepted:
%mem=24GB                 OR          %mem=24GB
%nprocshared=12           OR          %nproc=12

You may notice that ORCA file input takes its memory in the units of MB instead of GB
This is an entirely intentional inclusion of historical differences, in order to
further enforce that the program looks for specific formatting to distinguish between
the job types. QChem input is revered of Gaussian16 because that's the way it was in
the original submission script and I refuse to reinvent the wheel.

-------------------------------------genSP flag--------------------------------------

The genSP functionality is accessed through the -sp or --singlePoint flag, and
similarly accepts an escaped filename or list from the terminal.

This function was designed to operate on Gaussian16 outputs to generate G16 or ORCA
inputs (QChem support pending) for single point corrections. In your /bin/ folder,
where you keep this program, you should create a file called benchmarking.txt or
download the provided one on GitHub. This file is where the function will find your
desired single point method. You should specify the method similarly to shown below:

M062X 6-311+G(d,p) scrf=(smd,solvent=TetraHydroFuran)

This line will be read and inserted into the new single point input exactly as it
appears. It is therefore vital that you format this line exactly how whatever program
you want to calculate with will need to read it.

genSP will create submission files based off of either the user-specified program
associations within /bin/programs.txt , or a nonexhaustive list of hardcoded
defaults. It is recommended to do all editing via a programs.txt file formatted like
below:

M062X G16
DLPNO-CCSD(T) O
wB97M-V Q

Where the computational method is defined first, and the shorthand code for the
target program is second.

Within the code of the program, near the top, is a line for default CPU count and
default memory ratio. When building job files, the program will assign the default
CPU count, and ram equivalent to the CPU count x memory ratio.

genSP automatically reads the geometry output reference to find the charge and
multiplicity, so there is never any need to specify that information (a noticeable
QoL improvement from prior scripts).This function will not only create and
automatically submit the single point inputs, but it will also generate an XYZ file
for your own use in programs like CYLView (or in the case of ORCA, as part of the
input).

------------------------------------genBench flag------------------------------------

The benchmarking functionality is accessed by -b or --bench flags, and accepts a G16
output as its input. This runs extremely similarly to genSP, so the differences will
be enumerated here.

genBench will first pass through genSP to make the standard single point and generate
the XYZ file. This was an optimization decision to reduce the number of calls to
getCoords. Subsequent benchmark inputs are generated from the other lines of
benchmarking.txt and submitted to the intended suite of choice (G16 or ORCA). The XYZ
file that is created during the genSP routine is what is read and accessed for
quickly creating the other inputs (or in the case of ORCA inputs, the XYZ file is
used explicitly as the input geometry. It is therefore very important to leave this
file in the directory, and copy it out if needed).

-----------------------------------jobStalking flag----------------------------------

Finally operational, an automatic queue checking function termed job stalking, is 
achieved by -s or --stalk. It takes no inputs, instead setting a flag within the 
program to compile the list of jobs it submits to watch (in an improved measure from 
obsessiveQueue).

jobStalk informs you about the following properties of its compiled list of jobs:
- currently in the queue
- currently running (in which case, the CMD will be deleted)
- finished successfully
- finished via error termination

It will run this check periodically, based on the time specified by the frequency and
duration defaults within the defaults section near the top of the program. Change 
these variables depending on how often you desire updates on your jobs.

jobStalking will automatically terminate when all jobs have terminated, or when its
default duration has been exceeded.

-----------------------------------gimmeCubes flag-----------------------------------

Accessed via the -cu or --cube flag, gimmeCubes has been entirely improved from its
standalone module. This flag requires the specification of a valid fchk file.

gimmeCubes runs interactively with the user, allowing you to select the types of cube
files to generate based on the defaults specified in the program. Currently supports:
	Density 	via 	Den
	Potential 	via 	Pot
	Valence MO's 	via 	Val
	Spin 		via 	Spin

*************************************************************************************

Planned features:
- checkpoint flag for file generation
- re-optimization flag for re-running the exact same job with the final coordinates
    of the failed job

Desired features (will likely require collaboration with other lab mates):
- inclusion of mixed basis-set handling for genSP and genBench
- inclusion of PES generation (Thomas Tugwell)
- continued incorporation of other functions we handle by one-off scripts

Suggested features:
- Make program executable
- Make program object-oriented

=====================================================================================

+===================================================================================+
|                                                                                   |
|      _____         _           _           _      ____       _        _ _         |
|     |_   _|__  ___| |__  _ __ (_) ___ __ _| |    |  _ \  ___| |_ __ _(_) |___     |
|       | |/ _ \/ __| '_ \| '_ \| |/ __/ _` | |    | | | |/ _ \ __/ _` | | / __|    |
|       | |  __/ (__| | | | | | | | (_| (_| | |    | |_| |  __/ || (_| | | \__ \    |
|       |_|\___|\___|_| |_|_| |_|_|\___\__,_|_|    |____/ \___|\__\__,_|_|_|___/    |
|                                                                                   |
|                                                                                   |
+===================================================================================+

CompUtils was built by a novice programmer with the intention of simplifying a job
that many people create many single-function scripts to do. As such, there are bound
to be inefficiencies in the code that could be improved upon. In this section, some
of the design philosophy and decisions are described. Ultimately, however, CompUtils
was written in an attempt to be as user-readable as possible, so modifications should
be convenient enough to make.

For functions that act upon files, they can accept either a single filename or a
wildcard to grab all files in the current working directory. In order to ensure the
program works from the /bin/, CompUtils will make sure it accesses the absolute paths
of every file it is handed or creates. Since it can accept a list of files, every
function by default will iterate through the entire list of files passed into it.

A chunk of the code is a translated carry-over from other in-house scripts within the
group that work fine but are tedious to modify due to their lack of documentation
and nondescriptive variable names. This means that many functions operate at a fairly
high level of efficiency (or, at least, as efficient as the group is used to).

Due to new subprocess capabilities and intense refactoring, CompUtils is
significantly faster than it was in the past. This is mainly due to the ~10x speed
improvement made through the complete re-write of getCoords -> coordinateScraper,
which leverages a properly shell-executable version of the PERL script pg2xyz that
the group has relied on for its entire lifetime. My previous pure Python solution was
functional, but slower by an order of magnitude. I still learned a lot from this poor
solution, but am infinitely happier that I finally figured out a faster
implementation.