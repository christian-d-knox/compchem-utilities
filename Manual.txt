+===================================================================================+
|                                                                                   |
|    ____                      _   _ _   _ _                          ____    ___   |
|   / ___|___  _ __ ___  _ __ | | | | |_(_| |___   __   _____ _ __   |___ \  / _ \  |
|  | |   / _ \| '_ ` _ \| '_ \| | | | __| | / __|  \ \ / / _ | '__|    __) || | | | |
|  | |__| (_) | | | | | | |_) | |_| | |_| | \__ \   \ V |  __| |      / __/ | |_| | |
|   \____\___/|_| |_| |_| .__/ \___/ \__|_|_|___/    \_/ \___|_|     |_____(_\___/  |
|                       |_|                                                         |
|                                                                                   |
+===================================================================================+

Welcome to Computational Chemistry Utilities (CompUtils)!
This utility is brought to you by Christian Drew Knox, for the Peng Liu Group at The
University of Pittsburgh.

This program exists to combine many in-house scripts we have developed over the years
into one comprehensive package for anyone's use.

Current Implementations:
- Every function is pre-packaged with runall functionality
- qg16, qorca, and qchem submission
- genosp and genCC (mixed basis finally implemented)
- pg2xyz functionality
- genbench
- Installer file for conda and conda environment
- Colored terminal text (wow!)
- gimmeCubes and obsessiveQueue functionality (includes c and c1 in obsessiveQueue)
- Interactively run GoodVibes and export data directly to Excel
- Runs on H2P (Default), Bridges2, Stampede3
- Checkpoint generation and formatting
- NBO7 keylist addition
- genreopt via an improved re-run function

This utility comes pre-packaged with terminal flags that trigger its corresponding
features. This manual is sorted by these flags, in a semi-arbitrary ordering.

*************************************************************************************

+===================================================================================+
|                                                                                   |
|           ____   _                                      _                         |
|          / ___| | |__     __ _   _ __     __ _    ___  | |   ___     __ _         |
|         | |     | '_ \   / _` | | '_ \   / _` |  / _ \ | |  / _ \   / _` |        |
|         | |___  | | | | | (_| | | | | | | (_| | |  __/ | | | (_) | | (_| |        |
|          \____| |_| |_|  \__,_| |_| |_|  \__, |  \___| |_|  \___/   \__, |        |
|                                          |___/                      |___/         |
|                                                                                   |
+===================================================================================+

--------------------------------CompUtils 2.3 Release--------------------------------
- Fixed a bug in NBO keylist creation with NBO flag
- Fixed some spacing issues in jobStalking by splitting up the "currently running"
 line into multiple lines with indents
- Added first-time set-up function to determine what HPC cluster CompUtils is being
 accessed from
 - Currently supports H2P, Bridges2, Stampede3
  - H2P Defaults are smp and pliu
  - Bridges2 Defaults are RM-shared
  - Stampede3 Defaults are icx
 - After setting the HPC type on first command-line call, CompUtils will remember
  the architecture using the hpc.type file it generates in ~/bin
 - Expanse is not supported because I literally cannot initialize conda on it
 - First time set-up details now appear at the top of the Flags section
- SLURM commands for .cmd files are now handled in a separate function in order to
 accommodate the flexibility of multiple HPC types
 - This has also led to a slight refactoring of gimmeCubes
 - QChem submission is still only partially supported, as it requires more testing
- Added the re-run flag for running a failed job over again
 - This will take the EXACT method line, charge, and multiplicity used prior, along
  with the final coordinate list, from the failed output
  - This cannot fix fundamental syntax issues, this is meant to re-run jobs that
   errored out, timed out, etc.

--------------------------------CompUtils 2.2 Release--------------------------------
- Added an entire routing for running GoodVibes interactively through a series of y/n
 questions
 - Most questions cover the common keylist, but less-common input can be accepted in
  the final prompt
 - Data is given in the normal Goodvibes_output.dat and the automatically generated
  GoodVibes.xslx
 - Call this with the "-gv" flag and the filelist you plan to use (e.g. "\*.out")
- Added a flag for automatic NBO7 keylist in Gaussian file generation routines
 - This uses the STERIC keyword, which automatically turns on basically every other
  keyword in the potential keylist
 - If this behavior is not desired, edit this in the Defaults
- Bin directory is now found automatically, no more need to specify within the
 program
- Very minor speed improvement in RegEx modernization of charge finder module
 - This newer architecture will also allow an easier time expanding it to other
  programs
- Fixed a bug in jobStalking where if the output file was created mid-execution it
 crapped out
- Migrated development environment to conda environment. Ideally this does not create
 any issues
- Finally caved on making some lines multiline in order to be more readable
- Updated docstrings within the program
- Added index override flag to skip around within benchmarking.txt for more
 controlled single point and benchmark runs
- Added feature to genBench to add "SMD" to filemask if it detects the SMD section of
 the method line
 - This means if running the same method in both gas phase and in solution, the two
  files are more distinguishable than just by their index alone

--------------------------------CompUtils 2.1 Release--------------------------------
- Re-wrote bits of runJob to align with the H2P OS upgrade
 - Several times, as they kept changing it
- Something in the xyzfile submission in ORCA has fundamentally broken so it has been
 replaced with just the coordinate block for the time being.
- jobStalking terminal flag bug fixed
- jobStalking now tells you if a job is Queued, Running, or Terminated
 - Differentiates between Normal and Error termination
 - Jobs noted as Running will be automatically checked for convergence criteria
- Re-wrote installer entirely to utilize miniconda and a custom conda environment
 - New installer will put in development version of miniconda3, and required
  compUtils environment. Ideally this circumvents the retarded package management on
  H2P
- Had to completely rewrite coordinateScraper because the H2P OS upgrade broke the
 PERL dependency script from before the ancient times of yesteryear
 - Now utilizes a purely Pythonic version of RegEx to accomplish the same goal in the
  exact same time frame, based on internal testing
- Migrated from re to regex for increased functionality
- Implemented support for mixed basis sets in G16 via local (cwd) mixedbasis.txt
 detection for the following keywords: Gen GenECP gen genecp
 - Support is only for individual keywords, use of slash nomenclature will not work
- Fixed several bugs in genFile created from the massive overhauls of the 2.0 release
- Implemented gimmeCubes functionality with interactively triggered keywords
- Changed the filenaming convention of genBench to be easily interpretable
- Updated gimmeCubes to accept both .chk and .fchk with automatic checkpoint
 formatting
- Fully implemented checkpoint generation flag
- Other assorted bugfixes I'm too stupid to remember without writing them down

--------------------------------CompUtils 2.0 Release--------------------------------
- Completely refactored code into Python 3.10 to allow for match / case statements
instead of if / elif / else chains (speed improvement)
 - Refactored job submission to match Program with File Extension by match / case
  - Added Q-Chem job submission
 - Refactored file creation to match / case for File Extension
  - Default extensions are hardcoded but user changeable, similar to other defaults
 - Refactored both of the above to work with new Method determination
- Refactored default programs to user defined pairings of Method and Program
 - Provided a hardcoded default as fallback
 - Also provided hardcoded default single point method to avoid potential errors
- Re-wrote coordinate scraper to rely on external pg2xyz (speed improvement of ~10x)
- Reduced internal copypasta with more globally defined functions
- Added check for benchmarking file to block access to benchmarking flag
- Added preliminary section for QChem single point building
- Refactored default CPU and RAM assignments to use core:mem ratio
 - Provided a normal and high mem ratio for user tweaking (currently DLPNO-CCSD(T))
- Added colored text functionality to make terminal print easier to read / interpret
- Created installer file to automatically install package dependencies
 - Also creates aliases for proper python module and for CompUtils itself,
 immediately sources alias file for user convenience
- Re-wrote job CPU and RAM finder to be order-independent in the first 5 lines
- Implemented a working version of Job Stalking

*************************************************************************************

+===================================================================================+
|                                                                                   |
|                           _____   _                                               |
|                          |  ___| | |   __ _    __ _   ___                         |
|                          | |_    | |  / _` |  / _` | / __|                        |
|                          |  _|   | | | (_| | | (_| | \__ \                        |
|                          |_|     |_|  \__,_|  \__, | |___/                        |
|                                               |___/                               |
|                                                                                   |
+===================================================================================+

----------------------------------FIRST TIME SET-UP----------------------------------

When calling CompUtils for the first time from the command line on any HPC system, it
will prompt the user for the HPC type it is running on. Below are a list of accepted
architectures, and the associated Defaults that this will set.

    H2P             cluster = smp
                    partition = pliu
                    This is the unchanged default experience
                    H2P is the only HPC that has the correct QChem version that
                        CompUtils accesses.

    Bridges2        partition = RM-shared
                    memoryRatio = 2
                    memoryBuffer = 0
                    highMemoryRatio = 2
                    Bridges2 does NOT allow memory customization. These values merely
                        reflect how Bridges2 handles its memory:core ratio

    Stampede3       partition = icx
                    CPUS = 80
                    memoryRatio = 200/80
                    memoryBuffer = 0
                    highMemoryRatio = 200/80
                    Stampede3 reserves and bills by node-hours, so the defaults are
                        set to ensure a full icx node is reserved
                    Stampede3 does NOT have any ORCA versions installed that I can
                        see via module spider. Be careful.

CompUtils will create a file called hpc.type in your ~/bin folder to store what HPC
you are using. When accessing it any time after the first, it will read the file and
automatically adjust its Defaults accordingly.

---------------------------------------run flag--------------------------------------

The runJob function is accessed through the -r or --run flag, and must receive a file
name or escaped list of names as an argument. Multiple filenames can be
accepted by escaping the wildcard in the terminal, as shown in the example below:

    cu -r \*.gjf

The run function distinguishes between Gaussian16, ORCA, and QChem jobs based on
their respective file extensions. These defaults can be changed within CompUtils.
CPU and RAM determinations, however are based off of the first few lines, and as such
they must be formatted in a specific way. The first five lines of the input file must
contain the CPU and RAM information.

For Gaussian16 jobs, two different CPU structures are accepted:
    %nprocshared=12           OR          %nproc=12
    %mem=24GB                 OR          %mem=24GB

For ORCA submissions, one CPU and RAM input configuration is accepted:
    %pal=12
    end
    %maxcore=6000

For QChem submissions, two configurations are accepted:
    %mem=24GB                 OR          %mem=24GB
    %nprocshared=12           OR          %nproc=12

You may notice that ORCA file input takes its memory in the units of MB instead of GB
This is an entirely intentional inclusion of historical differences, in order to
further enforce that the program looks for specific formatting to distinguish between
the job types. We run jobs in QChem even less than ORCA, thus I merely used the
original formatting from its independent script.

It is worth noting that BOTH CompUtils and your program of choice are going to expect
this information somewhere. I cannot be bothered to fix your own files for you.

-------------------------------------genSP flag--------------------------------------

The genSP functionality is accessed through the -sp or --singlePoint flag, and
similarly accepts an escaped filename or list from the terminal.

This function was designed to operate on Gaussian16 outputs to generate G16 or ORCA
inputs (QChem support pending) for single point corrections. In your /bin/ folder,
where you keep this program, you should create a file called benchmarking.txt or
download the provided one on GitHub. This file is where the function will find your
desired single point method. You should specify the method similarly to shown below:

    M062X 6-311+G(d,p) scrf=(smd,solvent=TetraHydroFuran)

This line will be read and inserted into the new single point input exactly as it
appears. It is therefore vital that you format this line exactly how whatever program
you want to calculate with will need to read it.

genSP will create submission files based off of either the user-specified program
associations within ~/bin/programs.txt , or a nonexhaustive list of hardcoded
defaults. It is recommended to do all editing via a programs.txt file formatted like
below:

    M062X G16
    DLPNO-CCSD(T) O
    wB97M-V Q

Where the computational method is defined first, and the shorthand code for the
target program is second. Any method that does not appear in programs.txt nor the
hardcoded defaults will be assumed a G16 method.

Mixed basis sets are now finally accessible for G16 jobs only. To do this in the
least painful way (for the end-user) possible, you should create a file called
mixedbasis.txt within the working directory of the jobs needing the mixed basis.
Edit this file to the exact formatting of your mixed basis info, such as in the
example on GitHub. Activate this functionality by any of the following keywords:

    Gen     OR     GenECP     OR     gen     OR     genecp

Since the mixedbasis.txt file is strictly read from the cwd, this means you can
easily run different jobs with different mixed bases as long as they're in different
cwd's with their own text files.

Within the code of the program, near the top, is a line for default CPU count and
default memory ratio. When building job files automatically, the program will assign
the default CPU count, and ram equivalent to the CPU count x memory ratio. For
example, a default core count of 12 and memory ratio of 2 will request 12 * 2 = 24
GB of RAM (before the additional buffer).

genSP automatically reads the geometry output reference to find the charge and
multiplicity, so there is never any need to specify that information (a noticeable
QoL improvement from prior scripts).This function will not only create and
automatically submit the single point inputs, but it will also generate an XYZ file
for your own use in programs like CYLView. Filemasks will be generated using a
pattern to denote them (Default: "_SP").

------------------------------------genBench flag------------------------------------

The benchmarking functionality is accessed by -b or --bench flags, and accepts a G16
output as its input, similar to genSinglePoint. This runs extremely similarly to
genSP, so the differences will be enumerated here.

genBench will first pass through genSP to make the standard single point and generate
the XYZ file. Subsequent benchmark inputs are generated from the other lines of
benchmarking.txt and submitted to the intended suite of choice (G16 / ORCA / QChem).

The filename formatting of genBench assumes two things: you know what your default
single point method is, and you understand index based counting. For a benchmark of
functionals Triangle, Apple, and Whattaburger, the filenames on some_complex will be:

    some_complex_SP.gjf and .out
    some_complex-1-Apple_SP.gjf and .out
    some_complex-2-Whattaburger_SP.gjf and .out

The above assumes all are G16 methods, but the -index- and Functional are both
included in the filename to make it much easier to know which is what at a glance.
If the method line includes the SMD solvation method, "SMD" will be included in the
filemask to distinguish "Whattaburger" (gas phase) from "WhattaburgerSMD" (solvated).

------------------------------------genReRun flag------------------------------------

Accessed via the -re or --rerun flag, this accepts failed G16 outputs (as of now) to
generate new G16 inputs. This is primarily intended for optimizations.

CompUtils will prompt you for the syntax of your keylist, with a simple Y/N question:

    opt freq FUNCTIONAL keys        ->          y
    FUNCTIONAL keys                 ->          n

These are the two common ways an input may be built manually (or automatically), thus
both are accepted. CompUtils is programmed to use a different internal index with
each, to properly utilize the input keylist scrapped from the file with CompUtils'
architecture.

A new job will be built with the final coordinate list of the failed job, the
original charge, multiplicity, and keylist. Thus, CompUtils cannot fix errors such as
incorrect electron count, or incorrect keys (typo, etc.). The new job will be created
and submitted with a filemask pattern to denote it (Default: "_re").

----------------------------------indexOverride flag---------------------------------

Accessed via the -ovr or --override flag, this accepts an index-based integer
argument and will skip ahead in the benchmarking.txt file to the index provided. This
is most useful if the user wants to selectively run a specific method that isn't the
first line (the genSP default), or wants to begin their benchmark at a later line (in
which case genBench will continue to count forward from the provided starting index)

-----------------------------------checkpoint flag-----------------------------------

The checkpoint flag is accessed by -ch or --check, and will set an internal flag
within the program. When CompUtils creates G16 job with this flag enabled, it will
add in a line for checkpoint file generation, for later processing by the user (such
as cube file generation).

---------------------------------------nbo flag--------------------------------------

Accessed via the -nbo or --nbo7 flag, this will append the default NBO7 keylist to
the bottom of the G16 input file that CompUtils generates. For the functional and
basis set Sugar and Spice, correctly call NBO7 in your method line:

    # Sugar Spice pop=nbo7read

This keyword will activate the passthrough for NBO7 (assuming you have it installed
and configured). For the job everythingNice , the default NBO7 keylist that CompUtils
uses is:

    $NBO STERIC ARCHIVE FILE=everythingNice $END

This is because the STERIC keyword automatically activates most of the other NBO7
keys without needing to specify them.

-----------------------------------jobStalking flag----------------------------------

Finally operational, an automatic queue checking function termed job stalking, is 
achieved by -s or --stalk. It takes no inputs, instead setting a flag within the 
program to compile the list of jobs it submits to watch (in an improved measure from 
obsessiveQueue).

jobStalk informs you about the following properties of its compiled list of jobs:
- currently in the queue
- currently running
- how many convergence flags the last step achieved
- finished successfully
- finished via error termination

It will run this check periodically, based on the time specified by the frequency and
duration defaults within the defaults section near the top of the program. Change 
these variables depending on how often you desire updates on your jobs.

jobStalking will automatically terminate when all jobs it identified as tagged have
terminated, or when its default duration has been exceeded.

-----------------------------------gimmeCubes flag-----------------------------------

Accessed via the -cu or --cube flag, gimmeCubes has been entirely improved from its
standalone module. This flag requires the specification of a valid .chk or .fchk
file. If a .chk file is provided, the program will format the checkpoint to an .fchk
first. Note: this will force a module purge in your terminal.

gimmeCubes runs interactively with the user, allowing you to select the types of cube
files to generate based on the defaults specified in the program. It currently
supports the following cube types:
	Density 	    via 	Den
	Potential 	    via 	Pot
	Valence MO's 	via 	Val
	Spin 		    via 	Spin

------------------------------------goodVibes flag-----------------------------------

Accessed via the -gv or --goodvibes flag, this chains together both of the related
functions, goodVibesInteractive and goodVibesProcessor. You must provide the file or
escaped filelist you plan to use with GoodVibes.

    cu -gv \*.out

Simply answer a series of y/n questions (providing additional info when needed) for
the most common words in your keylist, and add any less common keys you want to use.

Both the normal GoodVibes output, and a now properly formatted Excel file, will be
generated in your cwd. This is a significant improvement over the original
goodVibesToExcel script, as the file generated is properly formatted, and rewritten
like an actual thinking human who cares did it.

*************************************************************************************

Planned features:
- re-optimization flag for re-running the exact same job with the final coordinates
    of the failed job

Desired features (will likely require collaboration with other lab mates):
- inclusion of PES generation (Thomas Tugwell)
- continued incorporation of other functions we handle by one-off scripts

Suggested features:
- Make program executable

=====================================================================================

+===================================================================================+
|                                                                                   |
|      _____         _           _           _      ____       _        _ _         |
|     |_   _|__  ___| |__  _ __ (_) ___ __ _| |    |  _ \  ___| |_ __ _(_) |___     |
|       | |/ _ \/ __| '_ \| '_ \| |/ __/ _` | |    | | | |/ _ \ __/ _` | | / __|    |
|       | |  __/ (__| | | | | | | | (_| (_| | |    | |_| |  __/ || (_| | | \__ \    |
|       |_|\___|\___|_| |_|_| |_|_|\___\__,_|_|    |____/ \___|\__\__,_|_|_|___/    |
|                                                                                   |
|                                                                                   |
+===================================================================================+

CompUtils was built by a novice (likely now considered intermediate) programmer with
the intention of simplifying a job that many people create many single-function
scripts to do. As such, there is always room for improvement in the code that I
aspire to make as good as I can. In this section, some of the design philosophy and
decisions are described. Ultimately, however, CompUtils was written in an attempt to
be as user-readable as possible, so modifications should be convenient enough to make.

For functions that act upon files, they can accept either a single filename or a
wildcard to grab all files in the current working directory. Since it can accept a
list of files, every function by default will iterate through the entire list of
files passed into it.

A chunk of the code is a translated carry-over from other in-house scripts within the
group that work fine but are tedious to modify due to their lack of documentation
and nondescriptive variable names. This means that many functions operate at a fairly
high level of efficiency (or, at least, as efficient as the group is used to).

The biggest under-the-hood magic is the Molecule object, which stores multiple
important data types that a complex may require. This is how the program is able to
achieve its speed even when doing a significant number of operations per file in a
large batch of files.

I've been very happy to pick up many news skills and knowledge as I've engaged in the
problem-solving required to achieve my goal of an easy-to-use universal one-stop-shop
type of tool for the group. Tinkering is a passion of mine, and while it may lead to
frequent frustration, and I may be seen as reinventing the wheel, my only desire is
to help myself and everyone else through the fruits of my labor.